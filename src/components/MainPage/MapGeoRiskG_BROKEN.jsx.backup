import { useEffect, useRef, useState, useCallback } from "react";
import maplibregl from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import { MapboxOverlay } from "@deck.gl/mapbox";
import MapLegend from "./MapLegend";

export default function GeoRiskMapDashboard({
  // Constants from parent
  districts,
  districtCoordinates,
  riskLabelMap,
  categoryLabelMap,
  // State from parent
  filters,
  setFilters,
  // Filter handlers from parent
  toggleRiskLevel,
  toggleCategory,
  selectDistrict,
  resetToAllDistricts,
  // Legacy props (for backward compatibility)
  mode,
  setMode,
  selectedDistrict,
  densityLevels,
}) {
  const mapContainer = useRef(null);
  const mapRef = useRef(null);
  const overlayRef = useRef(null);
  const isFirstRender = useRef(true);
  const [mapLoaded, setMapLoaded] = useState(false);
  const [geoStructsLoaded, setGeoStructsLoaded] = useState(false);

  // State management
  const [geoData, setGeoData] = useState(null);
  const [mapStyle] = useState("basic");

  const [, setStats] = useState({
    totalAreas: 0,
    highRisk: 0,
    mediumRisk: 0,
    lowRisk: 0,
  });

  // Build API query
  const buildQuery = useCallback(() => {
    const params = [];

    // Districts
    if (filters.districts.length > 0) {
      const districtList = filters.districts.map((d) => `${d} —Ä–∞–π–æ–Ω`).join(",");
      params.push(`district=${encodeURIComponent(districtList)}`);
    }

    // Risk levels
    const selectedRisks = Object.entries(filters.riskLevels)
      .filter(([_, enabled]) => enabled)
      .map(([key]) => riskLabelMap[key]);

    const allRisks = Object.values(filters.riskLevels).every((v) => v);
    const noRisks = Object.values(filters.riskLevels).every((v) => !v);

    if (noRisks) {
      params.push(`GRI_class=${encodeURIComponent("_none_")}`);
    } else if (!allRisks && selectedRisks.length > 0) {
      params.push(`GRI_class=${encodeURIComponent(selectedRisks.join(","))}`);
    }

    return params.length
      ? `?${params.join("&")}&page_size=5000`
      : "?page_size=5000";
  }, [filters.districts, filters.riskLevels, riskLabelMap]);

  // Fetch geo data with caching
  useEffect(() => {
    const fetchData = async () => {
      try {
        const query = buildQuery();
        const cacheKey = `geostructures_${query}`;
        const cacheTimestampKey = `${cacheKey}_timestamp`;
        const CACHE_DURATION = 60 * 60 * 1000; // 1 hour in milliseconds

        // Check cache first
        const cachedData = localStorage.getItem(cacheKey);
        const cachedTimestamp = localStorage.getItem(cacheTimestampKey);
        const now = Date.now();

        if (cachedData && cachedTimestamp) {
          const age = now - parseInt(cachedTimestamp);
          if (age < CACHE_DURATION) {
            console.log(
              "‚úÖ Loading geostructures from cache (age:",
              Math.round(age / 1000),
              "seconds)"
            );
            const data = JSON.parse(cachedData);

            // Process cached data same way as fresh data
            if (data?.features) {
              const normalized = data.features
                .filter((f) =>
                  [
                    "Point",
                    "LineString",
                    "MultiLineString",
                    "Polygon",
                    "MultiPolygon",
                  ].includes(f.geometry?.type)
                )
                .map((f) => {
                  const raw = f.properties?.category?.toLowerCase?.() || "";
                  if (raw.includes("–æ–ø–æ–ª–∑")) f.properties.category = "–æ–ø–æ–ª–∑–Ω–∏";
                  else if (raw.includes("—Ä–∞–∑–ª–æ–º"))
                    f.properties.category = "—Ä–∞–∑–ª–æ–º—ã";
                  else if (raw.includes("—Å–µ–ª—å")) f.properties.category = "—Å–µ–ª—å";
                  return f;
                });

              setGeoData({ ...data, features: normalized });

              const high = normalized.filter(
                (f) => f.properties?.GRI_class === "–≤—ã—Å–æ–∫–∏–π"
              ).length;
              const medium = normalized.filter(
                (f) => f.properties?.GRI_class === "—Å—Ä–µ–¥–Ω–∏–π"
              ).length;
              const low = normalized.filter(
                (f) => f.properties?.GRI_class === "–Ω–∏–∑–∫–∏–π"
              ).length;

              setStats({
                totalAreas: normalized.length,
                highRisk: high,
                mediumRisk: medium,
                lowRisk: low,
              });

              console.log(
                "üíæ Loaded",
                normalized.length,
                "features from cache"
              );
              return; // Exit early, use cached data
            }
          } else {
            console.log(
              "‚è∞ Cache expired (age:",
              Math.round(age / 1000),
              "seconds), fetching fresh data"
            );
          }
        }

        // No cache or expired - fetch from API
        console.log("üîÑ Fetching fresh geostructures data from API...");
        const res = await fetch(
          `https://admin.smartalmaty.kz/api/v1/address/clickhouse/geostructures${query}`
        );

        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }

        const data = await res.json();
        console.log("üì¶ Raw geostructures response:", data);

        // Cache the response
        try {
          localStorage.setItem(cacheKey, JSON.stringify(data));
          localStorage.setItem(cacheTimestampKey, now.toString());
          console.log("üíæ Cached geostructures data for future use");
        } catch (e) {
          console.warn("‚ö†Ô∏è Failed to cache data (localStorage full?):", e);
        }

        if (data?.features) {
          const normalized = data.features
            .filter((f) =>
              [
                "Point",
                "LineString",
                "MultiLineString",
                "Polygon",
                "MultiPolygon",
              ].includes(f.geometry?.type)
            )
            .map((f) => {
              const raw = f.properties?.category?.toLowerCase?.() || "";
              if (raw.includes("–æ–ø–æ–ª–∑")) f.properties.category = "–æ–ø–æ–ª–∑–Ω–∏";
              else if (raw.includes("—Ä–∞–∑–ª–æ–º"))
                f.properties.category = "—Ä–∞–∑–ª–æ–º—ã";
              else if (raw.includes("—Å–µ–ª—å")) f.properties.category = "—Å–µ–ª—å";
              return f;
            });

          // Debug: Show category breakdown
          const categoryCounts = normalized.reduce((acc, f) => {
            const cat = f.properties?.category || "unknown";
            acc[cat] = (acc[cat] || 0) + 1;
            return acc;
          }, {});
          const geometryTypes = normalized.reduce((acc, f) => {
            const type = f.geometry?.type || "unknown";
            acc[type] = (acc[type] || 0) + 1;
            return acc;
          }, {});
          console.log(
            "‚úÖ Loaded geostructures:",
            normalized.length,
            "features"
          );
          console.log("üìä Categories:", categoryCounts);
          console.log("üìê Geometry types:", geometryTypes);

          // Set geoData
          setGeoData({ ...data, features: normalized });
          console.log("üíæ geoData state updated");

          // Update stats
          const high = normalized.filter(
            (f) => f.properties?.GRI_class === "–≤—ã—Å–æ–∫–∏–π"
          ).length;
          const medium = normalized.filter(
            (f) => f.properties?.GRI_class === "—Å—Ä–µ–¥–Ω–∏–π"
          ).length;
          const low = normalized.filter(
            (f) => f.properties?.GRI_class === "–Ω–∏–∑–∫–∏–π"
          ).length;

          setStats({
            totalAreas: normalized.length,
            highRisk: high,
            mediumRisk: medium,
            lowRisk: low,
          });
        } else {
          console.warn("‚ö†Ô∏è No features found in geostructures response");
          setGeoData({ type: "FeatureCollection", features: [] });
        }
      } catch (err) {
        console.error("‚ùå Failed to fetch geostructures data:", err);
        setGeoData({ type: "FeatureCollection", features: [] });
      }
    };

    fetchData();
  }, [buildQuery]);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || mapRef.current) return;

    const API_KEY = "9zZ4lJvufSPFPoOGi6yZ";

    const map = new maplibregl.Map({
      container: mapContainer.current,
      style: `https://api.maptiler.com/maps/basic-v2/style.json?key=${API_KEY}`,
      center: [76.906, 43.198],
      zoom: 11,
      pitch: 45,
      bearing: 0,
      antialias: true,
    });

    mapRef.current = map;
    overlayRef.current = new MapboxOverlay({ interleaved: true, layers: [] });

    map.addControl(new maplibregl.NavigationControl(), "top-right");

    map.on("load", () => {
      console.log("üó∫Ô∏è Map loaded event fired");
      setMapLoaded(true);
      map.addControl(overlayRef.current);
      console.log(
        "‚úÖ Map initialized, waiting for geostructures to load first"
      );
    });

    return () => {
      if (mapRef.current) {
        try {
          mapRef.current.remove();
        } catch (e) {
          console.warn("Error removing map:", e);
        }
        mapRef.current = null;
      }
    };
  }, []);

  // Update map style (only when user changes it, not on initial load)
  useEffect(() => {
    if (!mapRef.current || !mapLoaded) return;

    // Skip the first run (map already has a style from initialization)
    if (isFirstRender.current) {
      console.log("‚è≠Ô∏è Skipping initial style change");
      isFirstRender.current = false;
      return;
    }

    console.log("üé® Changing map style to:", mapStyle);

    // Reset geoStructsLoaded flag so layers are recreated in correct order
    setGeoStructsLoaded(false);

    const API_KEY = "9zZ4lJvufSPFPoOGi6yZ";
    const styleUrls = {
      basic: `https://api.maptiler.com/maps/basic-v2/style.json?key=${API_KEY}`,
      streets: `https://api.maptiler.com/maps/streets-v2/style.json?key=${API_KEY}`,
      satellite: `https://api.maptiler.com/maps/hybrid/style.json?key=${API_KEY}`,
    };

    mapRef.current.setStyle(styleUrls[mapStyle]);

    // Layers will be automatically recreated by effects:
    // 1. GeoStructs effect will recreate geoStruct layers
    // 2. Tiles effect will recreate tiles AFTER geoStructs (ensuring correct order)
    console.log(
      "üîÑ Style changed, layers will be recreated automatically in correct order"
    );
  }, [mapStyle, mapLoaded, buildQuery]);

  // Add geoStruct layers to map
  const addGeoStructLayers = useCallback(
    (map) => {
      console.log(
        "üèóÔ∏è addGeoStructLayers called, styleLoaded:",
        map.isStyleLoaded()
      );
      if (!map.isStyleLoaded()) {
        console.log("‚ùå Style not loaded, cannot add layers");
        return false;
      }

      // Add source if it doesn't exist
      let hasSource = false;
      try {
        hasSource = !!(map.getSource && map.getSource("geoStruct"));
      } catch (e) {
        console.warn("Error checking source:", e);
      }
      console.log("üì¶ Source check:", { hasSource });

      if (!hasSource) {
        try {
          console.log("‚ûï Adding geoStruct source");
          map.addSource("geoStruct", {
            type: "geojson",
            data: geoData || { type: "FeatureCollection", features: [] },
          });
        } catch (e) {
          console.warn("Error adding source:", e);
          return false;
        }
      }

      // Add layers if they don't exist
      let hasFaultFill = false;
      try {
        hasFaultFill = !!(map.getLayer && map.getLayer("fault-fill"));
      } catch (e) {
        console.warn("Error checking fault-fill layer:", e);
      }
      console.log("üîç Checking fault-fill layer:", hasFaultFill);

      if (!hasFaultFill) {
        try {
          console.log("‚ûï Adding fault-fill layer");
          map.addLayer({
            id: "fault-fill",
            type: "fill",
            source: "geoStruct",
            filter: [
              "all",
              [
                "in",
                ["geometry-type"],
                ["literal", ["Polygon", "MultiPolygon"]],
              ],
              ["==", ["get", "category"], "—Ä–∞–∑–ª–æ–º—ã"],
            ],
            paint: {
              "fill-color": "#ff6b35",
              "fill-opacity": 0.5,
            },
          });
        } catch (e) {
          console.warn("Error adding fault-fill layer:", e);
        }
      }

      let hasStructLines = false;
      try {
        hasStructLines = !!(map.getLayer && map.getLayer("struct-lines"));
      } catch (e) {
        console.warn("Error checking struct-lines layer:", e);
      }
      console.log("üîç Checking struct-lines layer:", hasStructLines);

      if (!hasStructLines) {
        try {
          console.log("‚ûï Adding struct-lines layer");
          map.addLayer({
            id: "struct-lines",
            type: "line",
            source: "geoStruct",
            filter: [
              "in",
              ["geometry-type"],
              ["literal", ["LineString", "MultiLineString"]],
            ],
            paint: {
              "line-color": [
                "match",
                ["get", "category"],
                "—Å–µ–ª—å",
                "#00b4d8",
                "—Ä–∞–∑–ª–æ–º—ã",
                "#ff6b35",
                "–æ–ø–æ–ª–∑–Ω–∏",
                "#ffa500",
                "#888",
              ],
              "line-width": 3,
              "line-opacity": 0.8,
            },
          });
        } catch (e) {
          console.warn("Error adding struct-lines layer:", e);
        }
      }

      let hasStructPoints = false;
      try {
        hasStructPoints = !!(map.getLayer && map.getLayer("struct-points"));
      } catch (e) {
        console.warn("Error checking struct-points layer:", e);
      }
      console.log("üîç Checking struct-points layer:", hasStructPoints);

      if (!hasStructPoints) {
        try {
          console.log("‚ûï Adding struct-points layer");
          map.addLayer({
            id: "struct-points",
            type: "circle",
            source: "geoStruct",
            filter: ["==", ["geometry-type"], "Point"],
            paint: {
              "circle-radius": 8,
              "circle-color": "#ffa500",
              "circle-stroke-width": 2,
              "circle-stroke-color": "#fff",
              "circle-opacity": 0.85,
            },
          });
        } catch (e) {
          console.warn("Error adding struct-points layer:", e);
        }
      }

      console.log("üé® GeoStruct layers added/verified");
      return true;
    },
    [geoData]
  );

  // Update geoStruct data and ensure layers exist
  useEffect(() => {
    console.log("üîç GeoStruct effect triggered", {
      hasMap: !!mapRef.current,
      hasData: !!geoData,
      mapLoaded,
      featureCount: geoData?.features?.length,
    });

    if (!mapRef.current || !geoData || !mapLoaded) {
      console.log("‚è∏Ô∏è Skipping - waiting for:", {
        map: !mapRef.current,
        data: !geoData,
        loaded: !mapLoaded,
      });
      return;
    }

    const map = mapRef.current;

    const updateData = () => {
      console.log("‚öôÔ∏è updateData called, styleLoaded:", map.isStyleLoaded());
      if (!map.isStyleLoaded()) {
        console.log("‚è≥ Style not ready, scheduling retry...");
        setTimeout(updateData, 100);
        return;
      }

      // Ensure layers exist (recreate after style change)
      const layersCreated = addGeoStructLayers(map);

      let src = null;
      try {
        src = map.getSource && map.getSource("geoStruct");
      } catch (e) {
        console.warn("Error getting geoStruct source:", e);
      }

      if (src) {
        console.log(
          "üó∫Ô∏è Updating geoStruct data, features:",
          geoData.features?.length
        );
        try {
          src.setData(geoData);
        } catch (e) {
          console.warn("Error setting data on source:", e);
          return;
        }

        // Debug: Check layer existence
        ["fault-fill", "struct-lines", "struct-points"].forEach((layerId) => {
          try {
            if (map.getLayer && map.getLayer(layerId)) {
              const visibility = map.getLayoutProperty(layerId, "visibility");
              console.log(`  Layer ${layerId}: ${visibility || "visible"}`);
            } else {
              console.log(`  Layer ${layerId}: NOT FOUND`);
            }
          } catch (e) {
            console.log(`  Layer ${layerId}: ERROR checking - ${e.message}`);
          }
        });

        // Mark geostructs as loaded so tiles can be added on top
        setGeoStructsLoaded(true);

        // Trigger filter update after layers are created
        if (layersCreated) {
          console.log("üîÑ Layers just created, triggering filter update...");
          // Force a small delay to ensure layers are fully initialized
          setTimeout(() => {
            const visibilityEvent = new CustomEvent("layers-ready");
            window.dispatchEvent(visibilityEvent);
          }, 100);
        }

        console.log("‚úÖ GeoStructs loaded, tiles will now be added on top");
      } else {
        console.log("‚ùå geoStruct source not found!");
      }
    };

    // Use timeout to give the map time to fully initialize
    const timeoutId = setTimeout(updateData, 50);

    return () => clearTimeout(timeoutId);
  }, [geoData, mapLoaded, addGeoStructLayers]);

  // Add tiles AFTER geostructures are loaded (so geostructs appear on top)
  useEffect(() => {
    if (!mapRef.current || !mapLoaded || !geoStructsLoaded) {
      console.log("‚è∏Ô∏è Waiting to add geo risk data:", {
        mapLoaded,
        geoStructsLoaded,
      });
      return;
    }

    const map = mapRef.current;

    console.log("üó∫Ô∏è Loading geo risk data from API...");

    const loadGeoRiskData = async () => {
      if (!map.isStyleLoaded()) {
        console.log("‚è≥ Style not ready for geo risk, retrying...");
        setTimeout(loadGeoRiskData, 100);
        return;
      }

      const startTime = performance.now();

      try {
        // Clean up existing layers/sources
        if (map.getLayer && map.getLayer("geoRisk-fill")) {
          map.removeLayer("geoRisk-fill");
        }
        if (map.getSource && map.getSource("geoRisk")) {
          map.removeSource("geoRisk");
        }
      } catch (e) {
        console.warn("Error during layer cleanup:", e);
      }

      try {
        // Build query based on current filters
        const query = buildQuery();
        
        // –í–ê–ñ–ù–û: –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –æ–≥—Ä–æ–º–Ω—ã–π page_size —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∑–∞ 1 –∑–∞–ø—Ä–æ—Å
        const pageSize = 500000; // –ë–æ–ª—å—à–µ —á–µ–º 388k features
        const separator = query ? '&' : '?';
        const apiUrl = `https://admin.smartalmaty.kz/api/v1/address/clickhouse/geo-risk${query}${separator}page_size=${pageSize}`;

        console.log("üì° Fetching from:", apiUrl);
        console.log("‚è±Ô∏è [TIMING] Starting fetch...");

        const fetchStart = performance.now();
        const response = await fetch(apiUrl);
        const fetchEnd = performance.now();
        console.log(
          `‚è±Ô∏è [TIMING] Network request: ${(fetchEnd - fetchStart).toFixed(0)}ms`
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const parseStart = performance.now();
        const data = await response.json();
        const parseEnd = performance.now();
        console.log(
          `‚è±Ô∏è [TIMING] JSON parsing: ${(parseEnd - parseStart).toFixed(0)}ms`
        );
        console.log(
          `üì¶ Received ${data.features?.length || 0} features (total in DB: ${
            data.count || 0
          })`
        );

        if (!data.features || data.features.length === 0) {
          console.warn("‚ö†Ô∏è No features in response");
          return;
        }

        // OPTIMIZATION: –£–ø—Ä–æ—Å—Ç–∏—Ç—å –≥–µ–æ–º–µ—Ç—Ä–∏—é –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∞
        const simplifyStart = performance.now();
        const simplifiedFeatures = data.features.map((feature, idx) => {
          // Progress indicator –∫–∞–∂–¥—ã–µ 50k features
          if (idx % 50000 === 0 && idx > 0) {
            console.log(
              `  ...simplifying ${idx}/${data.features.length} features`
            );
          }

          if (!feature.geometry || !feature.geometry.coordinates)
            return feature;

          // –£–ø—Ä–æ—â–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (3 –∑–Ω–∞–∫–∞ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π = ~111–º —Ç–æ—á–Ω–æ—Å—Ç—å)
          const simplifyCoords = (coords) => {
            if (typeof coords[0] === "number") {
              return [
                Math.round(coords[0] * 1000) / 1000,
                Math.round(coords[1] * 1000) / 1000,
              ];
            }
            return coords.map(simplifyCoords);
          };

          // –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º properties (—Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ –ø–æ–ª—è)
          return {
            type: feature.type,
            geometry: {
              type: feature.geometry.type,
              coordinates: simplifyCoords(feature.geometry.coordinates),
            },
            properties: {
              GRI_class: feature.properties.GRI_class,
              color_GRI: feature.properties.color_GRI,
              district: feature.properties.district,
              address: feature.properties.address,
            },
          };
        });
        const simplifyEnd = performance.now();
        console.log(
          `‚è±Ô∏è [TIMING] Simplification: ${(simplifyEnd - simplifyStart).toFixed(
            0
          )}ms`
        );

        const simplifiedData = {
          type: "FeatureCollection",
          features: simplifiedFeatures,
        };

        // Add GeoJSON source
        const sourceStart = performance.now();
        map.addSource("geoRisk", {
          type: "geojson",
          data: simplifiedData,
          tolerance: 1.5, // –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ —É–ø—Ä–æ—â–µ–Ω–∏–µ
          buffer: 0,
          generateId: true,
        });
        const sourceEnd = performance.now();
        console.log(
          `‚è±Ô∏è [TIMING] Source creation: ${(sourceEnd - sourceStart).toFixed(
            0
          )}ms`
        );

        // Add tile layer BEFORE the first geoStruct layer
        const firstGeoStructLayer = map.getLayer("fault-fill")
          ? "fault-fill"
          : map.getLayer("struct-lines")
          ? "struct-lines"
          : map.getLayer("struct-points")
          ? "struct-points"
          : undefined;

        const layerStart = performance.now();
        map.addLayer(
          {
            id: "geoRisk-fill",
            type: "fill",
            source: "geoRisk",
            paint: {
              "fill-color": [
                "case",
                ["has", "color_GRI"],
                ["get", "color_GRI"],
                "#33a456",
              ],
              "fill-opacity": 0.45,
            },
          },
          firstGeoStructLayer
        );
        const layerEnd = performance.now();
        console.log(
          `‚è±Ô∏è [TIMING] Layer creation: ${(layerEnd - layerStart).toFixed(0)}ms`
        );

        // Attach popup handlers
        map.on("click", "geoRisk-fill", (e) => {
          if (e.features && e.features.length > 0) {
            const props = e.features[0].properties;
            new maplibregl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(
                `
                <div style="padding: 8px;">
                  <h3 style="margin: 0 0 8px 0; font-weight: bold;">${
                    props.address || "–ì–µ–æ—Ä–∏—Å–∫"
                  }</h3>
                  <p style="margin: 4px 0;"><strong>–ö–ª–∞—Å—Å —Ä–∏—Å–∫–∞:</strong> ${
                    props.GRI_class || "N/A"
                  }</p>
                  <p style="margin: 4px 0;"><strong>–†–∞–π–æ–Ω:</strong> ${
                    props.district || "N/A"
                  }</p>
                </div>
              `
              )
              .addTo(map);
          }
        });

        map.on("mouseenter", "geoRisk-fill", () => {
          map.getCanvas().style.cursor = "pointer";
        });

        map.on("mouseleave", "geoRisk-fill", () => {
          map.getCanvas().style.cursor = "";
        });

        const totalElapsed = ((performance.now() - startTime) / 1000).toFixed(
          1
        );
        console.log(`‚úÖ üéâ TOTAL TIME: ${totalElapsed}s`);
        console.log(`üìä Performance breakdown:`);
        console.log(
          `  - Network: ${((fetchEnd - fetchStart) / 1000).toFixed(1)}s`
        );
        console.log(
          `  - Parsing: ${((parseEnd - parseStart) / 1000).toFixed(1)}s`
        );
        console.log(
          `  - Simplify: ${((simplifyEnd - simplifyStart) / 1000).toFixed(1)}s`
        );
        console.log(
          `  - Source: ${((sourceEnd - sourceStart) / 1000).toFixed(1)}s`
        );
        console.log(
          `  - Layer: ${((layerEnd - layerStart) / 1000).toFixed(1)}s`
        );

        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
        console.log(`‚úÖ Geo risk data loaded in ${elapsed}s`);
      } catch (error) {
        console.error("‚ùå Failed to load geo risk data:", error);
      }
          ? "fault-fill"
          : map.getLayer("struct-lines")
          ? "struct-lines"
          : map.getLayer("struct-points")
          ? "struct-points"
          : undefined;

        map.addLayer(
          {
            id: "geoRisk-fill",
            type: "fill",
            source: "geoRisk",
            paint: {
              "fill-color": [
                "case",
                ["has", "color_GRI"],
                ["get", "color_GRI"],
                "#33a456",
              ],
              "fill-opacity": 0.45,
            },
          },
          firstGeoStructLayer
        );

        // Attach popup handlers
        map.on("click", "geoRisk-fill", (e) => {
          if (e.features && e.features.length > 0) {
            const props = e.features[0].properties;
            new maplibregl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(
                `
                <div style="padding: 8px;">
                  <h3 style="margin: 0 0 8px 0; font-weight: bold;">${
                    props.address || "–ì–µ–æ—Ä–∏—Å–∫"
                  }</h3>
                  <p style="margin: 4px 0;"><strong>–ö–ª–∞—Å—Å —Ä–∏—Å–∫–∞:</strong> ${
                    props.GRI_class || "N/A"
                  }</p>
                  <p style="margin: 4px 0;"><strong>–†–∞–π–æ–Ω:</strong> ${
                    props.district || "N/A"
                  }</p>
                </div>
              `
              )
              .addTo(map);
          }
        });

        map.on("mouseenter", "geoRisk-fill", () => {
          map.getCanvas().style.cursor = "pointer";
        });

        map.on("mouseleave", "geoRisk-fill", () => {
          map.getCanvas().style.cursor = "";
        });

        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
        console.log(`‚úÖ Geo risk data loaded in ${elapsed}s`);
      } catch (error) {
        console.error("‚ùå Failed to load geo risk data:", error);
      }
    };

    const timeoutId = setTimeout(loadGeoRiskData, 100);
    return () => clearTimeout(timeoutId);
  }, [
    filters.districts,
    filters.riskLevels,
    buildQuery,
    mapLoaded,
    geoStructsLoaded,
  ]);

  // Update layer visibility and filters
  useEffect(() => {
    if (!mapRef.current || !mapLoaded || !geoData) return;
    const map = mapRef.current;

    const updateVisibility = () => {
      console.log(
        "üîß updateVisibility called, styleLoaded:",
        map.isStyleLoaded()
      );
      if (!map.isStyleLoaded()) {
        console.log("‚è∏Ô∏è Style not loaded, waiting...");
        return;
      }

      // Make sure layers exist before applying filters
      let hasStructLines, hasStructPoints, hasFaultFill;
      try {
        hasStructLines = !!(map.getLayer && map.getLayer("struct-lines"));
        hasStructPoints = !!(map.getLayer && map.getLayer("struct-points"));
        hasFaultFill = !!(map.getLayer && map.getLayer("fault-fill"));
      } catch (e) {
        console.warn("Error checking layer existence:", e);
        return;
      }

      console.log("üîç Layer check:", {
        hasStructLines,
        hasStructPoints,
        hasFaultFill,
      });

      if (!hasStructLines || !hasStructPoints || !hasFaultFill) {
        console.log(
          "‚è≥ Layers not ready yet, will retry when layers-ready event fires"
        );
        return;
      }

      // Build category filter based on enabled categories
      const enabledCategories = [];
      if (filters.categories.mudflow) enabledCategories.push("—Å–µ–ª—å");
      if (filters.categories.landslide) enabledCategories.push("–æ–ø–æ–ª–∑–Ω–∏");
      if (filters.categories.fault) enabledCategories.push("—Ä–∞–∑–ª–æ–º—ã");

      console.log(
        "üëÅÔ∏è Updating filters, enabled categories:",
        enabledCategories
      );
      console.log("üìã Current filter state:", filters.categories);

      // Update fault-fill layer (only —Ä–∞–∑–ª–æ–º—ã polygons)
      try {
        if (map.getLayer && map.getLayer("fault-fill")) {
          if (filters.categories.fault) {
            map.setLayoutProperty("fault-fill", "visibility", "visible");
          } else {
            map.setLayoutProperty("fault-fill", "visibility", "none");
          }
        }
      } catch (e) {
        console.warn("Error updating fault-fill layer:", e);
      }

      // Update struct-lines layer (—Å–µ–ª—å, –æ–ø–æ–ª–∑–Ω—ñ, —Ä–∞–∑–ª–æ–º—ã lines)
      try {
        if (map.getLayer && map.getLayer("struct-lines")) {
          if (enabledCategories.length > 0) {
            map.setLayoutProperty("struct-lines", "visibility", "visible");
            map.setFilter("struct-lines", [
              "all",
              [
                "in",
                ["geometry-type"],
                ["literal", ["LineString", "MultiLineString"]],
              ],
              ["in", ["get", "category"], ["literal", enabledCategories]],
            ]);
          } else {
            map.setLayoutProperty("struct-lines", "visibility", "none");
          }
        }
      } catch (e) {
        console.warn("Error updating struct-lines layer:", e);
      }

      // Update struct-points layer (only –æ–ø–æ–ª–∑–Ω—ñ points)
      try {
        if (map.getLayer && map.getLayer("struct-points")) {
          if (filters.categories.landslide) {
            map.setLayoutProperty("struct-points", "visibility", "visible");
            map.setFilter("struct-points", [
              "all",
              ["==", ["geometry-type"], "Point"],
              ["==", ["get", "category"], "–æ–ø–æ–ª–∑–Ω–∏"],
            ]);
          } else {
            map.setLayoutProperty("struct-points", "visibility", "none");
          }
        }
      } catch (e) {
        console.warn("Error updating struct-points layer:", e);
      }

      console.log("‚úÖ Filters applied:", {
        "fault-fill": filters.categories.fault ? "visible" : "hidden",
        "struct-lines":
          enabledCategories.length > 0
            ? `visible (${enabledCategories.join(", ")})`
            : "hidden",
        "struct-points": filters.categories.landslide ? "visible" : "hidden",
      });
    };

    // Listen for layers-ready event (triggered after layer creation)
    const handleLayersReady = () => {
      console.log("üéâ layers-ready event received");
      updateVisibility();
    };
    window.addEventListener("layers-ready", handleLayersReady);

    // Initial update with delay and retry mechanism
    const attemptUpdate = () => {
      if (map.isStyleLoaded()) {
        updateVisibility();
      } else {
        console.log(
          "‚è≥ Style not ready for visibility update, scheduling retry..."
        );
        setTimeout(attemptUpdate, 100);
      }
    };

    const timeoutId = setTimeout(attemptUpdate, 150);

    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener("layers-ready", handleLayersReady);
    };
  }, [filters.categories, mapLoaded, geoData]);

  // Auto-fly to districts when filters change
  useEffect(() => {
    if (!mapRef.current || !mapLoaded) return;

    const selectedDistricts = filters.districts;

    if (selectedDistricts.length === 1) {
      // Fly to specific district
      const district = selectedDistricts[0];
      if (districtCoordinates[district]) {
        mapRef.current.flyTo({
          center: districtCoordinates[district],
          zoom: 12,
          duration: 1500,
          essential: true,
        });
      }
    } else if (selectedDistricts.length === 0) {
      // Return to overview when no districts selected
      mapRef.current.flyTo({
        center: [76.906, 43.198],
        zoom: 11,
        duration: 1500,
        essential: true,
      });
    }
  }, [filters.districts, mapLoaded, districtCoordinates]);

  return (
    <div className="relative w-full h-screen bg-gray-900 overflow-hidden">
      {/* Map Container */}
      <div
        ref={mapContainer}
        className="absolute inset-0 w-full h-full"
        style={{ minHeight: "100vh" }}
      />

      <MapLegend />
    </div>
  );
}
